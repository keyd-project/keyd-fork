#!/usr/bin/env python3

import sys

codes = []
codes2 = []
for line in open('data/unicode.txt').readlines(): # Original source: https://www.unicode.org/Public/14.0.0/ucd/UnicodeData.txt
    try:
        code = int(line.split(';')[0], 16)

        # Ensure the character is encodable (surrogates are not)
        chr(code).encode('utf8')

        if (code >= 128 and code < 65536):
            codes.append(code)
        if (code >= 65536):
            codes2.append(code)
    except:
        pass

# We use the base36 encoded index as the compose sequence to minimize
# the total number of keysyms required.
def base36(n):
	chars = '0123456789abcdefghijklmnopqrstuvwxyz'

	s = ''

	s += chars[n // (len(chars)*len(chars)) % len(chars)]
	s += chars[n // len(chars) % len(chars)]
	s += chars[n % len(chars)]

	return s

# Generate the compose file

data = ''
for n, code in enumerate(codes):
        data += '<Cancel> '
        data += ' '.join(f'<{c}>' for c in base36(n))
        data += f' : "{chr(code)}"\n'
for n, code in enumerate(codes2):
        data += '<Cancel> '
        data += ' '.join(f'<{c}>' for c in base36(n + (65536 - 128)))
        data += f' : "{chr(code)}"\n'

open('data/keyd.compose', 'w').write(data)

# Generate the corresponding src/unicode.c

# OPT: We could condense this and shave off lookup time by using an offset
# table to capitalize on codepoint contiguity, but 35k is small enough to
# warrant keeping the entire thing in memory.

open('src/unicode.cpp', 'w').write(f'''
	/* GENERATED BY {sys.argv[0]}, DO NOT MODIFY BY HAND. */

	#include <stdint.h>
	#include <stdlib.h>
	#include "keys.h"
	#include <algorithm>
	#include <vector>
	#include <utility>
	#include <numeric>

	constexpr uint16_t unicode_table1[] = {{ {','.join(map(str, codes))} }};
	constexpr uint32_t unicode_table2[] = {{ {','.join(map(str, codes2))} }};

	constexpr auto cb = std::cbegin(unicode_table1);
	constexpr auto ce = std::cend(unicode_table1);

	// Compile time binary search assistant that will generate some branches to reduce search range
	template <typename T, const T* const& Begin, const T* const& End, size_t Max>
	static std::pair<const T*, const T*> lookup_range(uint32_t codepoint)
	{{
		if constexpr (size_t(End - Begin) <= Max) {{
			return std::make_pair(Begin, End);
		}} else {{
			static constexpr auto Mid = std::midpoint(Begin, End);
			if (codepoint < 0u + *Mid)
				return lookup_range<T, Begin, Mid, Max>(codepoint);
			else
				return lookup_range<T, Mid, End, Max>(codepoint);
		}}
	}}

	int unicode_lookup_index(uint32_t codepoint)
	{{
		// Slight search optimizations: prevent CPU from fetching data from unlikely areas
		static constexpr auto ce3 = std::lower_bound(cb, ce, 0x1100); // before hangul
		static constexpr auto ce4 = std::lower_bound(cb, ce3, 0x300); // after latin, modifiers
		auto beg = ce3;
		auto end = ce;

		if (codepoint < 0u + *ce4)
			std::tie(beg, end) = lookup_range<uint16_t, cb, ce4, 32>(codepoint);
		else if (codepoint < 0u + *ce3)
			std::tie(beg, end) = lookup_range<uint16_t, ce4, ce3, 64>(codepoint);
		else if (codepoint <= 0u + ce[-1])
			std::tie(beg, end) = lookup_range<uint16_t, ce3, ce, 256>(codepoint);
		else {{
			static constexpr auto cb2 = std::cbegin(unicode_table2);
			static constexpr auto ce2 = std::cend(unicode_table2);
			auto [beg2, end2] = lookup_range<uint32_t, cb2, ce2, 256>(codepoint);
			auto res = std::lower_bound(beg2, end2, codepoint);
			if (res != ce2 && *res == codepoint)
				return res - cb2 + (ce - cb);
			return -1;
		}}
		auto res = std::lower_bound(beg, end, codepoint);
		if (res != end && *res == codepoint)
			return res - cb;

		return -1;
	}}

	void unicode_get_sequence(int idx, uint8_t codes[4])
	{{
		uint8_t chars[] = {{
			KEYD_0, KEYD_1, KEYD_2, KEYD_3, KEYD_4, KEYD_5, KEYD_6, KEYD_7,
			KEYD_8, KEYD_9, KEYD_A, KEYD_B, KEYD_C, KEYD_D, KEYD_E, KEYD_F,
			KEYD_G, KEYD_H, KEYD_I, KEYD_J, KEYD_K, KEYD_L, KEYD_M, KEYD_N,
			KEYD_O, KEYD_P, KEYD_Q, KEYD_R, KEYD_S, KEYD_T, KEYD_U, KEYD_V,
			KEYD_W, KEYD_X, KEYD_Y, KEYD_Z
		}};

		codes[0] = KEYD_CANCEL;
		codes[1] = chars[idx / (36 * 36) % 36];
		codes[2] = chars[idx / 36 % 36];
		codes[3] = chars[idx % 36];
	}}

'''
.replace('\n\t', '\n')
.lstrip()
)
